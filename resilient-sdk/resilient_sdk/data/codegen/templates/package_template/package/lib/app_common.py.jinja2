# -*- coding: utf-8 -*-
# pragma pylint: disable=unused-argument, no-self-use

import logging
import time
from datetime import datetime
from io import BytesIO
from urllib.parse import urljoin
from resilient_lib import str_to_bool, readable_datetime
from cachetools import cached, LRUCache

#----------------------------------------------------------------------------------------
# This module is an open template for you to develop the methods necessary to interact
# with your endpoint solution. The only required methods are:
#  get_entities_since_ts: get your entities (alerts, events, etc.) based on a timestamp
#       since the last time the poller ran
# Helper functions:
#  authenicate: authenticate to your endpoint solution, yielding a token for ongoing API calls
#  _make_header: create the necessary API header for your endpoint communication
#  _make_linkback_url: create a url for your alert, event, etc. to navigate to your endpoint console
#  _get_uri: assemble the parts of your URL (base address, version information, command and arguments)
#  _api_call: perform the API call, passing parameters and check the returned status code before
#      returning the response object

LOG = logging.getLogger(__name__)

# change the header as necessary
HEADER = { 'Content-Type': 'application/json' }

# URL fragment to refer back to your console for a specific alert, event, etc.
LINKBACK_URL = ""

# E N D P O I N T S
# define the endpiont api calls your app will make to the endpoint solution. Below are expamples
#ALERT_URI = "alert/{}/"
#POLICY_URI = "policy/"

class AppCommon():
    def __init__(self, rc, options):
        """initialize the parameters needed to communicate to the endpoint solution

        Args:
            rc (obj): object to resilient_lib.requests_common for making API calls
            options (dict): app.config parameters in order to authenticate and access the endpoint
        """
        self.api_key = options['api_key']
        self.api_secret = options['api_secret']
        self.endpoint_url = options['endpoint_url']
        self.api_version = options['api_version']
        self.rc = rc
        self.verify = str_to_bool(options.get("cafile", "false"))

        # Specify any additional parameters needed to communicate with your endpoint solution
        self.token = self.header = None

        self.secret = self.authenticate()

    def authenticate(self):
        # modify to represent the data structure needed by the authenication API call
        params = {
            "secret": self.api_secret,
            "id": self.api_key
        }

        response, err_msg = self._api_call("POST", 'authenticate', params, refresh_authentication=None)
        if err_msg:
            LOG.error("{{package_name}} authenication failed: %s", err_msg)
            return None

        # modify to the return correct token used for ongoing api calls
        return response.json().get("token")

    def get_entities_since_ts(self, timestamp):
        """get changed entities since last poller run

        Args:
            timestamp (datetime): datetime when the last poller ran

        Returns:
            list: changed entity list
        """
        # change for the specific API calls
        query = {
            "query_field_name": readable_datetime(timestamp) # utc datetime format
        }

        LOG.debug(query)
        response, err_msg = self._api_call("GET", 'alerts', query, refresh_authentication=True)
        if err_msg:
            LOG.error("{{package_name}} API call failed: %s", err_msg)
            return None

        return response.json()

    def _get_uri(self, cmd):
        """build API url

        Args:
            cmd (str): portion of API: alerts, endpoints, policies

        Returns:
            str: complete URL
        """
        return urljoin(urljoin(self.endpoint_url, self.api_version), cmd)

    def _make_header(self, token):
        """Build API header using authorization token

        Args:
            token (str): authorization token

        Returns:
            dict: complete header
        """
        header = HEADER.copy()
        # modify to represent how to build the header
        header['Authorization'] = "Bearer {}".format(self.secret)

        return header

    def _make_linkback_url(self, entity_id, linkback_url=LINKBACK_URL):
        """Create a url to link back to the endpoint alert, case, etc.

        Args:
            template (str): portion of url to join with base url
            entity_id (str/int): id representing the alert, case, etc.

        Returns:
            str: completed url for linkback
        """
        return urljoin(self.endpoint_url, linkback_url.format(entity_id))

    def _api_call(self, method, url, payload, refresh_authentication=False):
        # make the api call to your endpoint solution. Different syntax is used whether
        #  making GET, PUT, and POST API calls. Modify as needed


        if method in ["PUT", "POST"]:
            return self.rc.execute(method,
                                   self._get_uri(url),
                                   json=payload,
                                   headers=self.header,
                                   verify=self.verify,
                                   callback=callback)
        if payload:
            return self.rc.execute(method,
                                   self._get_uri(url),
                                   params=payload,
                                   headers=self.header,
                                   verify=self.verify,
                                   callback=callback)

        return self.rc.execute(method,
                               self._get_uri(url),
                               headers=self.header,
                               verify=self.verify,
                               callback=callback)


def callback(response):
    """
    callback needed for certain REST API calls to return a formatted error message
    :param response: the requests response object
    :return: response, error_msg
    """
    error_msg = None
    if response.status_code >= 300 and response.status_code < 500:
        resp = response.json()
        msg = resp.get('messages') or resp.get('message')
        details = resp.get('details')
        error_msg  = u"{{package_name}} Error: \n    status code: {0}\n    message: {1}\n    details: {2}".format(
            response.status_code,
            msg,
            details)

    return response, error_msg
